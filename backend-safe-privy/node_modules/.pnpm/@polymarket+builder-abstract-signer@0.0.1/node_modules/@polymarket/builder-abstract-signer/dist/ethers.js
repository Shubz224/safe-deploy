"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthersSigner = void 0;
const ethers_1 = require("ethers");
class EthersSigner {
    chainId;
    provider;
    signer;
    constructor(chainId, signer) {
        this.chainId = chainId;
        if (signer.provider == undefined) {
            throw new Error("signer is missing provider");
        }
        this.signer = signer;
        this.provider = signer.provider;
    }
    async signMessage(message) {
        return this.signer.signMessage(ethers_1.ethers.utils.arrayify(message));
    }
    async signRawMessage(message) {
        return this.signer.signMessage(message);
    }
    async signTypedData(domain, types, value, _) {
        return this.signer._signTypedData(domain, types, value);
    }
    async getAddress() {
        return this.signer.getAddress();
    }
    async estimateGas(tx) {
        const gas = await this.provider.estimateGas({
            from: tx.from,
            to: tx.to,
            data: tx.data,
            nonce: tx.nonce,
        });
        return gas.toBigInt();
    }
    async signTransaction(tx) {
        return this.signer.signTransaction({
            to: tx.to,
            data: tx.data,
            value: tx.value,
            gasLimit: tx.gasLimit,
            gasPrice: tx.gasPrice,
            maxFeePerGas: tx.maxFeePerGas,
            maxPriorityFeePerGas: tx.maxPriorityFeePerGas,
            nonce: tx.nonce,
        });
    }
    async sendTransaction(tx) {
        const txn = await this.signer.sendTransaction({
            to: tx.to,
            data: tx.data,
            value: tx.value,
            gasLimit: tx.gasLimit,
            gasPrice: tx.gasPrice,
            maxFeePerGas: tx.maxFeePerGas,
            maxPriorityFeePerGas: tx.maxPriorityFeePerGas,
            nonce: tx.nonce,
        });
        return txn.hash;
    }
    async waitTillMined(txHash) {
        return this.provider.waitForTransaction(txHash);
    }
}
exports.EthersSigner = EthersSigner;
