"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViemSigner = void 0;
const viem_1 = require("viem");
const viem_utils_1 = require("./viem_utils");
class ViemSigner {
    chainId;
    walletClient;
    publicClient;
    constructor(chainId, walletClient) {
        this.chainId = chainId;
        if (walletClient.chain != undefined && walletClient.chain.id != chainId) {
            throw new Error("wallet client chain id does not match chain id");
        }
        this.walletClient = walletClient;
        const walletTransport = walletClient.transport;
        const transport = () => ({
            config: walletTransport.config,
            name: walletTransport.name,
            request: walletTransport.request,
            type: walletTransport.type,
            value: walletTransport.value,
        });
        this.publicClient = (0, viem_1.createPublicClient)({
            chain: (0, viem_utils_1.chainIdToChain)(chainId),
            transport: transport,
        });
    }
    async signMessage(message) {
        const [account] = this.walletClient.account ? [this.walletClient.account] : await this.walletClient.requestAddresses();
        const signableMessage = { raw: (0, viem_1.toBytes)(message) };
        return this.walletClient.signMessage({ account, message: signableMessage });
    }
    async signRawMessage(message) {
        const [account] = this.walletClient.account ? [this.walletClient.account] : await this.walletClient.requestAddresses();
        return this.walletClient.signMessage({ account, message: { raw: message } });
    }
    async signTypedData(domain, types, value, primaryType) {
        if (primaryType == undefined) {
            throw new Error("primaryType is required in viem signers");
        }
        const [account] = this.walletClient.account ? [this.walletClient.account] : await this.walletClient.requestAddresses();
        return this.walletClient.signTypedData({
            account,
            domain,
            types,
            primaryType: primaryType,
            message: value,
        });
    }
    async getAddress() {
        if (this.walletClient.account == undefined) {
            const [account] = await this.walletClient.requestAddresses();
            return account;
        }
        return this.walletClient.account.address;
    }
    async estimateGas(tx) {
        return this.publicClient.estimateGas({
            account: tx.from,
            to: tx.to,
            data: tx.data,
            nonce: tx.nonce,
        });
    }
    async signTransaction(tx) {
        const isEip1559 = tx.maxFeePerGas !== undefined || tx.maxPriorityFeePerGas !== undefined;
        const isLegacy = tx.gasPrice !== undefined;
        if (isEip1559 && isLegacy) {
            throw new Error("cannot specify both EIP1559 and legacy gas fields");
        }
        const [account] = this.walletClient.account
            ? [this.walletClient.account]
            : await this.walletClient.requestAddresses();
        if (isEip1559) {
            return this.walletClient.signTransaction({
                account,
                chain: this.walletClient.chain,
                to: tx.to,
                data: tx.data,
                value: tx.value,
                gas: tx.gasLimit,
                maxFeePerGas: tx.maxFeePerGas,
                maxPriorityFeePerGas: tx.maxPriorityFeePerGas,
                nonce: tx.nonce,
            });
        }
        if (isLegacy) {
            return this.walletClient.signTransaction({
                account,
                chain: this.walletClient.chain,
                to: tx.to,
                data: tx.data,
                value: tx.value,
                gas: tx.gasLimit,
                gasPrice: tx.gasPrice,
                nonce: tx.nonce,
            });
        }
        return this.walletClient.signTransaction({
            account,
            chain: this.walletClient.chain,
            to: tx.to,
            data: tx.data,
            value: tx.value,
            gas: tx.gasLimit,
            nonce: tx.nonce,
        });
    }
    async sendTransaction(tx) {
        const isEip1559 = tx.maxFeePerGas !== undefined || tx.maxPriorityFeePerGas !== undefined;
        const isLegacy = tx.gasPrice !== undefined;
        if (isEip1559 && isLegacy) {
            throw new Error("cannot specify both EIP1559 and legacy gas fields");
        }
        const [account] = this.walletClient.account
            ? [this.walletClient.account]
            : await this.walletClient.requestAddresses();
        if (isEip1559) {
            return this.walletClient.sendTransaction({
                account,
                chain: this.walletClient.chain,
                to: tx.to,
                data: tx.data,
                value: tx.value,
                gas: tx.gasLimit,
                maxFeePerGas: tx.maxFeePerGas,
                maxPriorityFeePerGas: tx.maxPriorityFeePerGas,
                nonce: tx.nonce,
            });
        }
        if (isLegacy) {
            return this.walletClient.sendTransaction({
                account,
                chain: this.walletClient.chain,
                to: tx.to,
                data: tx.data,
                value: tx.value,
                gas: tx.gasLimit,
                gasPrice: tx.gasPrice,
                nonce: tx.nonce,
            });
        }
        return this.walletClient.sendTransaction({
            account,
            chain: this.walletClient.chain,
            to: tx.to,
            data: tx.data,
            value: tx.value,
            gas: tx.gasLimit,
            nonce: tx.nonce,
        });
    }
    async waitTillMined(txHash) {
        return this.publicClient.waitForTransactionReceipt({
            hash: txHash,
        });
    }
}
exports.ViemSigner = ViemSigner;
